1. 程序计数器，虚拟机栈，本地方法栈三个区域随线程而生，随线程而灭。一般不会出现OOM等问题所以用过多的考虑。java堆和方法区是才是需要关注的区域。     
1. 判断堆中对象是否死亡的算法:     
    1. 引用计数法:记录每个对象的被引用次数，当引用次数为0时表明对象已死，但是这种方法难以结局循环引用的问题，所以主流的垃圾回收器都没有使用这种算法。    
    1. 可达性分析法:该算法的基本思路是通过一系列被称为“GC ROOTS”的对象作为起始点。从这些节点开始向下搜索，搜索所走过的路径称之为引用链。当一个对象到`GC ROOTS`没有任何引用相连则证明对象已经死亡。    
          1. java中的`GC ROOTS`包括:   
              1. 虚拟机抓（栈帧中的本地变量表）中引用的对象。    
              1. 方法区静态类属性引用的对象。   
              1. 方法区常量应用的对象。[常量和静态属的区别](https://blog.csdn.net/gideal_wang/article/details/4842933)     
              1. 本地方法栈中引用的对象。    
1. 引用的分类:根据什么情况下被回收分类的      
    1. 强引用:只要引用就不会被回收。     
    1. 软引用:在内存不够用的时候会被回收。        
    1. 弱引用:弱引用不影响被回收，在一个对象被多次引用如果某个引用在其他引用有效的时候才有意义那么该引用就应该被设置为弱引用[参考](https://www.jianshu.com/p/a7aaaf1bd7be)   
    1. 虚引用:虚引用和不被引用唯一的区别是在该对象被回收时收到一个系统通知。     
1. 对象在被回收是可以实现finalize()方法自救。      
1. 方法区回收:    
    1. 方法区主要回收的是废弃常量和无用的类，可以通过-Xnoclassgs来关闭方法区的回收，可以-verbose:class 和 -XTraceClassLoading来查看类的加载信息。    
1. 垃圾回收算法:   
    1. 标记清楚发: 标记和清除的效率都不高，产生大量碎片导致分配大对象时不得不触发垃圾回收这样所以导致垃圾回收较频繁。    
    1. 复制算法: 把内存分为两块每次只使用一块，当内存满了的时候把已死亡的对象回收掉剩下的移到另一块并不本块清空， 浪费内存。但是IBM公司专门研究表明98%的对象是朝生夕死存活时间特别短，所以并不需要按照1：1来分配内存空间，而是将内存空间氛围较大的Eden区和两个较小的的Suvivor区，默认的Eden和Suvivor的大小为8：1，每次可用内存为总容量的90% Eden+一个Suvivor内存回收时将还活着的对象复制到另一块Suvivor上。如果另一块Suvivor装不下则需要老年代来担保。    
    1. 标记整理法:复制算是在对象存活率比较高的情况下，效率会变低且需要额外的内存分配担保，所以在老年代一般不使用这种算法。所以老年代一般用标记整理发。    
    1. 分代算法:主流的虚拟机都是采用这种算法，这种算法并没有什么不同而是根据对象的存活周期不同把内存分为几块，java虚拟机一般把分为年轻代和老年代这样
    可以根据各个区代采用不同的垃圾回收算法。年轻代使用复制算法老年代使用标记整理或标记清除算法。    
    
