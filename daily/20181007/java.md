1. 程序计数器，虚拟机栈，本地方法栈三个区域随线程而生，随线程而灭。一般不会出现OOM等问题所以用过多的考虑。java堆和方法区是才是需要关注的区域。     
1. 判断堆中对象是否死亡的算法:     
    1. 引用计数法:记录每个对象的被引用次数，当引用次数为0时表明对象已死，但是这种方法难以结局循环引用的问题，所以主流的垃圾回收器都没有使用这种算法。    
    1. 可达性分析法:该算法的基本思路是通过一系列被称为“GC ROOTS”的对象作为起始点。从这些节点开始向下搜索，搜索所走过的路径称之为引用链。当一个对象到`GC ROOTS`没有任何引用相连则证明对象已经死亡。    
          1. java中的`GC ROOTS`包括:   
              1. 虚拟机栈（栈帧中的本地变量表）中引用的对象。    
              1. 方法区静态类属性引用的对象。   
              1. 方法区常量应用的对象。[常量和静态属的区别](https://blog.csdn.net/gideal_wang/article/details/4842933)     
              1. 本地方法栈中引用的对象。    
1. 引用的分类:根据什么情况下被回收分类的      
    1. 强引用:只要引用就不会被回收。     
    1. 软引用:在内存不够用的时候会被回收。        
    1. 弱引用:弱引用不影响被回收，在一个对象被多次引用如果某个引用在其他引用有效的时候才有意义那么该引用就应该被设置为弱引用[参考](https://www.jianshu.com/p/a7aaaf1bd7be)   
    1. 虚引用:虚引用和不被引用唯一的区别是在该对象被回收时收到一个系统通知。     
1. 对象在被回收是可以实现finalize()方法自救。      
1. 方法区回收:    
    1. 方法区主要回收的是废弃常量和无用的类，可以通过-Xnoclassgs来关闭方法区的回收，可以-verbose:class 和 -XTraceClassLoading来查看类的加载信息。    
1. 垃圾回收算法:   
    1. 标记清楚发: 标记和清除的效率都不高，产生大量碎片导致分配大对象时不得不触发垃圾回收这样所以导致垃圾回收较频繁。    
    1. 复制算法: 把内存分为两块每次只使用一块，当内存满了的时候把已死亡的对象回收掉剩下的移到另一块并不本块清空， 浪费内存。但是IBM公司专门研究表明98%的对象是朝生夕死存活时间特别短，所以并不需要按照1：1来分配内存空间，而是将内存空间氛围较大的Eden区和两个较小的的Suvivor区，默认的Eden和Suvivor的大小为8：1，每次可用内存为总容量的90% Eden+一个Suvivor内存回收时将还活着的对象复制到另一块Suvivor上。如果另一块Suvivor装不下则需要老年代来担保。    
    1. 标记整理法:复制算是在对象存活率比较高的情况下，效率会变低且需要额外的内存分配担保，所以在老年代一般不使用这种算法。所以老年代一般用标记整理发。    
    1. 分代算法:主流的虚拟机都是采用这种算法，这种算法并没有什么不同而是根据对象的存活周期不同把内存分为几块，java虚拟机一般把分为年轻代和老年代这样
    可以根据各个区代采用不同的垃圾回收算法。年轻代使用复制算法老年代使用标记整理或标记清除算法。    
1. 程序并不是在任何时刻都能进行GC的需要到达安全点。     
1. 垃圾收集器的种类:   
    1. serial单线程，但是由于它简单而高效在一些场景下也是不错的选择，比如单cpu模式下选择serial就没有切换线程的开销。     
    1. ParNew是serial的多线程版本。如果老年代使用CMS收集器的话年轻代默认使用ParNew。    
    1. parallel scavenge关注的吞吐量而不是停顿时间，在与用户交互的场景不是和用该收集器，后台任务比较适合用比如批处理程序。使用的复制算法。       
    1. Serial old Serial收集器的老年版本。     
    1. parallel old 是parallel scavenge的老年版本。解决了parallel scavenge收集器只能有Serial old收集器配合使用的尴尬。      
    1. CMS是一种获取最短暂停时间为目的的收集器。使用的是标记清除算法    
    1. G1收集器：是面向服务端的，目的是替换CMS收集器。         
        1. 并行与并发尽量缩短stop the word的时间。     
        1. 年轻代和年老代都可以收集     
        1. 使用标记-整理算法，不会产生大量的碎片。   
        1. 可预测停顿时间，这样做的好处还本人还不太清楚。     
        1. 与其他垃圾收集器的最大不同是吧内存分为不连续的多个区域这样就可以分开收集了。并且多了H(Humongous)区域大于区域一半大小的对象直接被分配到H区域[参考](https://www.mtyun.com/library/g1)       
1. GC日志
        1. 发生的时间，即虚拟机启动以来经过的秒数。    
        1. GC 和 FULL GC是区分这次垃圾收集的停顿类型而不是发生在年轻代还是老年代。FULL GC表示本次收集发生了stop the word。如果是手动调用System.gc()则显示为FULL GC(system)       
        1. DefNew ，Tenured Perm 表示GC发生的区域，这里显示的区域名称跟所使用的垃圾回收期有关。    
        1. xxxxK->yyyK(zzzzzK) ,GC前该区域已使用容量->GC后该区域已使用容量(该区域总容量) GC前堆已使用容量->GC后堆已使用容量(堆总容量)。    
        1. xxx secs 表示本次收集所有的时间单位是秒。有点垃圾收集器显示的时间会更详细`[Times: user=0.01
         sys=0.00 real=0.02 secs]`分表表示用户态，内核态和操作从开始到结束总的时间          
1. 垃圾回收相关参数: UsexxxGC用什么类型的垃圾回收器，Eden和suviver的比例，直接晋升到老年代的对象的大小，进入老年代的年龄，动态调整各个区域的大家及进入老年代的年龄。设置GC时的线程数。GC时间所占的比例(不知道有什么用)，设置GC的最大停顿时间。是在CMS收集器收集完后是否要进行整理。         
1. 内存有限分配到eden取，大对象直接分配到老年代，达到年龄的对象之间分配到老年代，还允许动态判断年龄如果Suvivor中所有同龄对象大总和大于suivivor空间的一般则大于等于该年龄的就会被回收掉。为了避免频繁的运行担保失败。                  
