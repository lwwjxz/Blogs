[命令行书籍1](http://billie66.github.io/TLCL/book/chap01.html)  

### 图形用户界面让简单的任务更容易完成， 而命令行界面使完成复杂的任务成为可能。  
1. bash是sh的增强版。  
1. shell提示符最后一个字符是#而不是$表明是以root用户登录。
1. `cd - 更改工作目录到先前的工作目录`  `cd ~user_name 更改工作目录到用户家目录。`    
1. /usr包含普通用户所需要的所有程序和文件。跟系统文件有些对应比如/bin包含系统启动和运行所必须的二进制程序而/usr/bin包含系统启动和运行所必须的二进制程序而/usr/local/bin是非系统发行版自带程序的安装目录.   
1. 除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。/var 目录存放的是动态文件。各种数据库，假脱机文件， 用户邮件等等，都位于在这里。个人理解为静态目录就是程序在运行的过程中不会去写的文件(安装程序的时候回写静态文件)。
1. 软连接的作用(有点像程序中的变量):
    >一个程序要求使用某个包含在名为“foo”文件中的共享资源，但是“foo”经常改变版本号。 这样，在文件名中包含版本号，会是一个好主意，因此管理员或者其它相关方，会知道安装了哪个“foo”版本。 这会导致另一个问题。如果我们更改了共享资源的名字，那么我们必须跟踪每个可能使用了 这个共享资源的程序，当每次这个资源的新版本被安装后，都要让使用了它的程序去寻找新的资源名。 这听起来很没趣。这就是符号链接存在至今的原因。比方说，我们安装了文件 “foo” 的 2.6 版本，它的 文件名是 “foo-2.6”，然后创建了叫做 “foo” 的符号链接，这个符号链接指向 “foo-2.6”。 这意味着，当一个程序打开文件 “foo” 时，它实际上是打开文件 “foo-2.6”。 现在，每个人都很高兴。依赖于 “foo” 文件的程序能找到这个文件，并且我们能知道安装了哪个文件版本。 当升级到 “foo-2.7” 版本的时候，仅添加这个文件到文件系统中，删除符号链接 “foo”， 创建一个指向新版本的符号链接。这不仅解决了版本升级问题，而且还允许在系统中保存两个不同的文件版本。 假想 “foo-2.7” 有个错误（该死的开发者！），那我们得回到原来的版本。 一样的操作，我们只需要删除指向新版本的符号链接，然后创建指向旧版本的符号链接就可以了。
 
1. 硬链接
