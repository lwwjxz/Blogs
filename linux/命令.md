[命令行书籍1](http://billie66.github.io/TLCL/book/index.html)  

### 图形用户界面让简单的任务更容易完成， 而命令行界面使完成复杂的任务成为可能。  
1. 查看命令的路径: `type cd`[参考](https://jingyan.baidu.com/article/4ae03de3e05edf3efe9e6b7c.html)    
1. bash是sh的增强版。  
1. shell提示符最后一个字符是#而不是$表明是以root用户登录。
1. `cd - 更改工作目录到先前的工作目录`  `cd ~user_name 更改工作目录到用户家目录。`    
1. /usr包含普通用户所需要的所有程序和文件。跟系统文件有些对应比如/bin包含系统启动和运行所必须的二进制程序而/usr/bin包含系统启动和运行所必须的二进制程序而/usr/local/bin是非系统发行版自带程序的安装目录.   
1. 除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。/var 目录存放的是动态文件。各种数据库，假脱机文件， 用户邮件等等，都位于在这里。个人理解为静态目录就是程序在运行的过程中不会去写的文件(安装程序的时候回写静态文件)。
1. 软连接(又叫符号链接)的作用(有点像程序中的变量):
    >一个程序要求使用某个包含在名为“foo”文件中的共享资源，但是“foo”经常改变版本号。 这样，在文件名中包含版本号，会是一个好主意，因此管理员或者其它相关方，会知道安装了哪个“foo”版本。 这会导致另一个问题。如果我们更改了共享资源的名字，那么我们必须跟踪每个可能使用了 这个共享资源的程序，当每次这个资源的新版本被安装后，都要让使用了它的程序去寻找新的资源名。 这听起来很没趣。这就是符号链接存在至今的原因。比方说，我们安装了文件 “foo” 的 2.6 版本，它的 文件名是 “foo-2.6”，然后创建了叫做 “foo” 的符号链接，这个符号链接指向 “foo-2.6”。 这意味着，当一个程序打开文件 “foo” 时，它实际上是打开文件 “foo-2.6”。 现在，每个人都很高兴。依赖于 “foo” 文件的程序能找到这个文件，并且我们能知道安装了哪个文件版本。 当升级到 “foo-2.7” 版本的时候，仅添加这个文件到文件系统中，删除符号链接 “foo”， 创建一个指向新版本的符号链接。这不仅解决了版本升级问题，而且还允许在系统中保存两个不同的文件版本。 假想 “foo-2.7” 有个错误（该死的开发者！），那我们得回到原来的版本。 一样的操作，我们只需要删除指向新版本的符号链接，然后创建指向旧版本的符号链接就可以了。
 
1. 硬链接只能指向文件不能指向目录，硬链接只是把原来文件的信息(这些信息为文件的在磁盘上的储存位置等)又拷贝一份，而软连接是指向的源文件,硬链接不能跨越物理设备。  
    >一个硬链接和文件本身没有什么区别。不像符号链接，当你列出一个包含硬链接的目录 内容时，你会看到没有特殊的链接指示说明。当一个硬链接被删除时，这个链接 被删除，但是文件本身的内容仍然存在（这是说，它所占的磁盘空间不会被重新分配）， 直到所有关联这个文件的链接都删除掉。知道硬链接很重要，因为你可能有时 会遇到它们，但现在实际中更喜欢使用符号链接，下一步我们会讨论符号链接。  
    
1. 创建连接 `ln -s 源文件 链接` 其中-s表示软连接，没有-s则创建符号链接。  
1. 命令的四种type。  
1. which 命令只对可执行程序有效，不包括内建命令和命令别名，别名是真正的可执行程序的替代物。 当我们试着使用 shell 内建命令时，例如，cd 命令，我们或者得不到回应，或者是个错误信息。  
1. cat 命令读取一个或多个文件，然后复制它们到标准输出。  
1. 命令替换`ls -l $(which cp)` 另一种老的写法``` ls -l `which cp` ```  ``` ` ```不是单引号是esc键底下的那个键。   
1. 后台启动 `command &`  列出从终端启动的进程的命令`jobs`,进程返回前台 `fg %jobs返回结果中的序号`，进程移到后台`bg %进程号`  
1. 停止进程前台`Ctrl + z`,终止进程`Ctrl+c`,退出进程节目比如bc `Ctrl+d`   
1. login shell和non login shell ，interactive shell与non-interactive shell [参考](http://blog.sciencenet.cn/blog-3238131-1037461.html)   
    > login 和 non login 区别主要是启动的时候读取的配置文件不同，login shell启动时首先读取/etc/profile全局配置，然后依次查找~/.bash_profile、\~/.bash_login、\~/.profile三个配置文件，并且读取第一个找到的并且可读的文件。/etc/profile是必读的剩下的三个找到一个就不会往下找了。non login分两种情况:交互式的和非交互式的交互式non login的启动时时候读取~/.bashrc，非交互式的non login不读取配置文件而是查找环境变量BASH_ENV，读取并执行BASH_ENV指向的文件中的命令。`通常我们要定制一些配置时，将配置写在~/.bashrc中，然后在~/.bash_profile中读取~/.bashrc，这样可以保证login shell和交互式non-login shell得到相同的配置。至于/etc/profile就不要轻易去改啦，毕竟会影响系统全局的配置。`  
    
1. 安装网络工具net-tools 只有安装了该工具才能使用`ifconfig`,`netstat`等命令，
1. 查看端口占用mac和linux通用`lsof -nP -iTCP:8080 -sTCP:LISTEN`
1. 查找文件`find 查找范围 -name XXX`  
1. tar命令  
    > `解压：tar zxvf FileName.tar.gz`   
      `压缩：tar zcvf FileName.tar.gz DirName`   
      z表示需要解压或压缩，x表示解包，c表示打包，v表示显示详情，f表示指定文件(为什么还有这个选项,难道还有不指定文件的情况)   
      
1. 一个 shell 脚本就是一个包含一系列命令的文件  
1. here document[参考](https://blog.csdn.net/wangjunjun2008/article/details/24351045),
    ```
    command<<delimiter
    xxxxxx
    delimiter
    ```
    其中command接受的参数必须是文档，比如cat 可以 echo不可。   
1. 查看上一个命令的退出状态`echo $?` 0表示成功其他表示失败。一个脚本的退出状态设置`exit 1`.  
1. `wc`(Word Count)命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出  
    >wc [选项]文件  
    -c 统计字节数。  
    -l 统计行数。  
    -m 统计字符数。这个标志不能与 -c 标志一起使用。  
    -w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。  
    -L 打印最长行的长度。    
1.  解压 `unrar x Httpclient_jar.rar `     

