1. 锁有个专门的名字：对象监视器。  
1. jdk1.6对锁做了优化，主要就是新加了偏向锁，轻量级锁和重量级的锁，这样就避免了在所有场景下都需要用重量级索来锁定资源的产生的效率问题。    
    1. 切换线程上下文需要用户态和内核态协调工作属于比较重量级的操作。   
    1. 偏向锁永远是获取锁的第一个线程拥有。不会切换线程上下文，不会自旋。如果只是少数情况下会出现多线程的场景则偏向锁是很有用的，比如读多写少。    
    1. 轻量级锁自旋，不会切换线程上下文。  
    1. 重量级锁，会切换线程上下文。   
    1. 锁只会升级不会降级。   
    1. jdk1.6和1.7偏向锁功能是默认开启的，如果你的同步资源或代码一直都是多线程访问的，那么消除偏向锁这一步骤对你来说就是多余的。事实上，消除偏向锁的开销还是蛮大的。
    所以在你非常熟悉自己的代码前提下，大可禁用偏向锁。   
    1. 关闭偏向锁：偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟 
    -XX：BiasedLockingStartupDelay = 0。如果你确定自己应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁
    -XX:-UseBiasedLocking=false，那么默认会进入轻量级锁状态。     
1. 锁消除，锁粗化 [参考](https://blog.csdn.net/chenssy/article/details/54883355)    
1. synchronized与java.util.concurrent包中的ReentrantLock相比，由于JDK1.6中加入了针对锁的优化措施（见后面），使得synchronized与ReentrantLock的性能基本持平。ReentrantLock只是提供了synchronized更丰富的功能，而不一定有更优的性能，所以在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。      
1. [好文](https://zhuanlan.zhihu.com/p/29866981)      

