1. [参考](https://www.cnblogs.com/fanjie/p/6916784.html)     
    1. 加载：将class文件加载到内存     
    2. 连接:    
        1. 验证： 验证class文件是否符合规范。   
        1. 准备: 为静态变量分配默认值。    
        1. 解析：把符号引用转化为地址引用。
    1. 初始化：为静态变量赋予初始值，连接-》准备阶段是默认值。
    1. 类加载的内存分析，class文件被加载到了方法区jdk8为元数据区。不同的类对应的class对象被放在堆中。    
1. [深入理解Java类加载器(1)：Java类加载原理解析](https://blog.csdn.net/zhoudaxia/article/details/35824249)     
    1. 自带类加载器: Bootstrap,Extension,System.    
    1. 动态扩展:是指运行时决定所使用的类型,当然接口要提前知道(除非用object)，实现方法有:    
        1. 调用java.lang.Class.forName
        1. 自定义类加载器
    1. jvm中一个类用其全名和一个类加载器作为类的唯一标识，不同类加载器加载的类将被置于不同的命名空间。
        1. 比如tomcat中不用的应用就要用不同的类加载器，这样可以避免不同应用出现重名类而引发的问题。    
    1. Class.forName(String name)默认会使用调用类的类加载器来进行类加载。
    1. 自定义类加载器时如果没有设置父加载器，那么默认采用系统类加载器。   
    1. 自定义加载器中强制将将Bootstrap类加载器设置为父类加载器。    
    猜测：    
        用java命令启动程序时，main类是被jvm调用的，而mian类即不在javahome\/lib也不再javahome\/lib\/ext下所以是被System类加载器加载的，如果是tomcat等有定义类加载器的程序肯定在代码里指定了用哪个类加载器。    
        
    
        

