1. 32位的jdk最多能分2G内存，64的最多能分2^64对比现在的硬件来说可以说是无穷大了。即就是linux上一个进程的内存限制。      
1. 内存模块(分为6个区域):       
    1. 程序计数器(PC 寄存器):较小的空间线程执行字节码的行号指示器。线程独有的(每个线程一条) 不太可能发生OOM。      
    1. java虚拟机栈:以栈帧为基本单位存储局部变量，操作数栈，动态链接，方法出口等信息，每一个方法对应一个栈帧。 
        1. 每个方法对饮的栈帧的大小是完全确定的。       
        1. 如果线程无法申请到足够的内存则OOM。     
        1. 如果栈的深度大于虚拟机运行的深度的报StackOverflowError。所以递归调用的时候要注意深度。      
        1. JVM规范规定虚拟机栈可动态扩展(目前虚拟机大部分不可以)，如果扩展的时候申请不到足够的内存会报OOM。     
    1. 本地方法栈: 跟java虚拟机栈唯一的不同是它是为java中调用的native方法服务的。sun hotspot虚拟中把他们合二为一了。          
    1. java堆: 各个线程共享的，此内存区域的唯一目的就是储存java对象实例，几乎所有的对象实例都分配在java堆中，是java垃圾收集器管理的主要区域。会抛出OOM。       
        1. 堆是垃圾收集器的主要管理区域。    
        1. 可以分为新生代和老年代，新生代又可以分为eden，from survivor，to survivor。      
    1. 方法区(HotSpot称为永久带): 各个线程共享的用于储存被加载的类信息，常量池，静态变量即时编译后的代码等数据，hotspot1.8开始不再有永久带，hotspot1.8方法区实现名叫Metaspace（元数据空间空间）。把原来永久带数据移到堆(字符串常量池等)中和Metaspace(class文件元信息描述，编译后的代码数据，引用类型数据，类文件常量池。)中。默认情况下Metaspace内存受本地内存大小的限制但是也可以设置[参考](https://www.cnblogs.com/paddix/p/5309550.html)，也有可能OOM因为动态代理等机制会生成方法     
    1. 直接内存: 并不是java虚拟机规范中的运行时时间区的一部分，但是也经常会被用到可能导致OOM      
        1. 内存会受物理机上的内存和操作系统一个进程所能分配的最多内存的限制，对于64位的操作系统来说可以认为只收物理内存测限制。    
        1. NIO就用了直接内存避免了BIO在内存中的来回复制，从而提高了性能。    
1. [jdk8](https://blog.csdn.net/bruce128/article/details/79357870)        
        跟7的区别
        1. 7中方法区中的数据被分别加载到了堆和元空间中。    
        1. 元空间不含有虚拟机内存，占用直接内存。     
1. [直接内存(堆外内存)](https://my.oschina.net/zjllovecode/blog/1853292)    
    1. 直接内存不属于 Java 堆，所以它不受堆大小限制，但是它受物理内存大小的限制。可以设置为很大。只要不超过物理内存。    
    1. 可以通过 -XX:MaxDirectMemorySize 参数来设置最大可用直接内存，如果启动时未设置则默认为最大堆内存大小，即与 -Xmx 相同。    
1. 进入老年代的几种方式
    1. 空间分配担保，minorGC是survivor空间不够。
    1. 大对象。
    1. 到了一定的年龄。
1. 垃圾回收发生的区域
    1. 新生代: Minor GC
    1. 老年代: Major/Full GC ,速度一般是Minor GC的10倍以上
