1. 32位的jdk最多能分2G内存，64的最多能分2^64对比现在的硬件来说可以说是无穷大了。即就是linux上一个进程的内存限制。      
1. 内存模块(分为6个区域):       
    1. 程序计数器(PC 寄存器):较小的空间线程执行字节码的行号指示器。线程独有的(每个线程一条) 不太可能发生OOM。      
    1. java虚拟机栈:以栈帧为基本单位存储局部变量，操作数栈，动态链接，方法出口等信息，每一个方法对应一个栈帧。 
        1. 如果线程无法申请到足够的内存则OOM。   
        1. 如果栈的深度大于虚拟机运行的深度的报StackOverflowError。所以递归调用的时候要注意深度。      
        1. JVM规范规定虚拟机栈可动态扩展(目前虚拟机大部分不可以)，如果扩展的时候申请不到足够的内存会报OOM。     
    1. 本地方法栈: 跟java虚拟机栈唯一的不同是它是为java中调用的native方法服务的。sun hotspot虚拟中把他们合二为一了。          
    1. java堆: 各个线程共享的，此内存区域的唯一目的就是储存java对象实例，几乎所有的对象实例都分配在java堆中，是java垃圾收集器管理的主要区域。会抛出OOM。       
    1. 方法区: 各个线程共享的用于储存被加载的类信息，常量池，静态变量即时编译后的代码等数据，hotspot1.8开始不再有永久带，hotspot1.8方法区实现名叫Metaspace（元空间）。把原来永久带数据移到堆(常量等)中和Metaspace(类的加载信息等)中。默认情况下Metaspace内存受本地内存大小的限制但是也可以设置[参考](https://www.cnblogs.com/paddix/p/5309550.html)     
    1. 直接内存: 并不是java虚拟机规范中的运行时时间区的一部分，但是也经常会被用到可能导致OOM      
        1. 内存会收物理机上的内存和操作系统一个进程所能分配的最多内存的限制，对于64位的操作系统来说可以认为只收物理内存测限制。    
        1. NIO就用了直接内存避免了BIO在内存中的来回复制，从而提高了性能。    
